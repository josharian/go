// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

// Generate reflectcall_amd64.s.

package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
)

func main() {
	buf := new(bytes.Buffer)

	// TODO: generated code preamble

	buf.WriteString(`// Code generated by gen_reflect_call.go. DO NOT EDIT.`)

	buf.WriteString(`

// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
`)

	buf.WriteString(`
#include "textflag.h"
#include "funcdata.h"
`)

	buf.WriteString(`
// reflect.call calls a function with the given argument list.
//   func call(argtype *_type, f *FuncVal, arg *byte, argsize, retoffset uint32)
// We do not have variable-sized frames, so we use a small number
// of constant-sized-frame functions to encode a few bits of size in the PC.
TEXT reflect·call(SB), NOSPLIT, $0-0
	JMP	·reflectcall(SB)
`)

	buf.WriteString(`
// callRet copies return values back at the end of call*. This is a
// separate function so it can allocate stack space for the arguments
// to reflectcallmove. It does not follow the Go ABI; it expects its
// arguments in registers.
TEXT callRet<>(SB), NOSPLIT, $32-0
	NO_LOCAL_POINTERS
	MOVQ	DX, 0(SP)
	MOVQ	DI, 8(SP)
	MOVQ	SI, 16(SP)
	MOVQ	CX, 24(SP)
	CALL	runtime·reflectcallmove(SB)
	RET
`)

	sizes := []int{
		32, 64, 128, 256, 512, 1024, 2048, 4096, 8192,
		16384, 32768, 65536, 131072, 262144, 524288, 1048576,
		2097152, 4194304, 8388608, 16777216, 33554432, 67108864,
		134217728, 268435456, 536870912, 1073741824,
	}

	// Implement reflectcall, which dispatches to the appropriate call function.
	buf.WriteString(`
TEXT ·reflectcall(SB), NOSPLIT, $0-32
	NO_LOCAL_POINTERS
	// load arguments into registers, used by the various call functions
	MOVQ	f+8(FP), DX
	MOVQ	argptr+16(FP), SI
	MOVLQZX argsize+24(FP), CX
`)

	for _, sz := range sizes {
		fmt.Fprintf(buf, "	CMPQ	CX, $%d\n", sz)
		fmt.Fprintf(buf, "	JA	3(PC)\n")
		// Note: can't just "JMP NAME(SB)" - bad inlining results.
		fmt.Fprintf(buf, "	MOVQ	$runtime·call%d(SB), AX\n", sz)
		fmt.Fprintf(buf, "	JMP	AX\n")
	}

	buf.WriteString(`
	MOVQ	$runtime·badreflectcall(SB), AX
	JMP	AX

`)

	// Implement the various call functions.
	for _, sz := range sizes {
		fmt.Fprintf(buf, "TEXT ·call%d(SB), WRAPPER, $%d-32\n", sz, sz)
		fmt.Fprintf(buf, "	NO_LOCAL_POINTERS\n")
		fmt.Fprintf(buf, "	MOVLQZX argsize+24(FP), CX\n")
		fmt.Fprintf(buf, "	MOVQ	SP, DI\n")
		fmt.Fprintf(buf, "	REP;MOVSB\n")
		fmt.Fprintf(buf, "	// call function\n")
		// fmt.Fprintf(buf, "	MOVQ	f+8(FP), DX\n")
		fmt.Fprintf(buf, "	PCDATA  $PCDATA_StackMapIndex, $0\n")
		fmt.Fprintf(buf, "	CALL	(DX)\n")
		fmt.Fprintf(buf, "	// copy return values back\n")
		fmt.Fprintf(buf, "	MOVQ	argtype+0(FP), DX\n")
		fmt.Fprintf(buf, "	MOVQ	argptr+16(FP), DI\n")
		fmt.Fprintf(buf, "	MOVLQZX	argsize+24(FP), CX\n")
		fmt.Fprintf(buf, "	MOVLQZX	retoffset+28(FP), BX\n")
		fmt.Fprintf(buf, "	MOVQ	SP, SI\n")
		fmt.Fprintf(buf, "	ADDQ	BX, DI\n")
		fmt.Fprintf(buf, "	ADDQ	BX, SI\n")
		fmt.Fprintf(buf, "	SUBQ	BX, CX\n")
		fmt.Fprintf(buf, "	CALL	callRet<>(SB)\n")
		fmt.Fprintf(buf, "	RET\n\n")
	}

	err := ioutil.WriteFile("reflectcall_amd64.s", buf.Bytes(), 0644)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}
